// 1. Структура данных - архитектурная конструкция определяющая методы хранения и обработки,
// связанных между собой данных. Простейшая структура данных массим с доступу элемента по индексу
// реализуется механикой языка программирования компилятора и процессора

// 2.1 ПЕРЕЧЕНЬ СТАНДАРТНЫХ СТРУКТУР
// по принципу FILO (first in - last out; первый пришел - последний ушел).
// Объявление стека			
//					std::stack<тип_данных> имя_переменной;
// Помещение данных в стек
//					имя_стекаю.push(значение);
// Извлечение данных из стека
//					переменная = имя_стека.pop();

// Примеры использования стека: анализ числа и закрывающихся скобок
// Аппаратный стек процессора для передачи параметров функций

// 2.2 Очередь - это структура данных, которая построена по принципу
// по принципу LILO last in - last out; первый пришел - последний ушел).
// Примеры: Очередь депонированных (отложенных) сообщений в мессенджерах,
// очередь команд в скриптовых языках, очередь системных сообщений 
// Объявление очереди		
//					std::queue<тип_данных> имя_переменной;
// Помещение данных в очередь
//					имя_очереди.push(значение);
// Извлечение данных из очереди
//					переменная = имя_очереди.pop();

// 2.3 Очередь с приоритетом (priority_queue) - это обычная очередь,
// но в ней новый элемент добавляется в такое место,
// чтобы очередь была отсортирована по убыванию.

// 2.4 Вектор Вектор является классом-контейнером
// Объявление
//			std::vector<тип_данных> имя_вектора
// Доступ к элементу вектора:
//			имя_вектора[номер] либо имя_вектора.at(номер)
// прочие свойства и мотоды могут быть просмотрены через IntelliSense или в документации c++


// 2.5 Класс массива (std::array) является классом-контейнером для массива постоянной длины
// Объявление
//			std::array<тип_данных> имя_класса
// Доступ к элементу вектора:
//			имя_массива[номер] либо имя_массива.at(номер)
// прочие свойства и мотоды могут быть просмотрены через IntelliSense или в документации c++

// 2.6 Список (list)

// 2.7 Словарь/именованный список (map)

// 2.8 Кортеж (turle)

// 2.9 Деревья: бинарные (pair)

// 


// В стеке нет индексов, т.е нельзя обратится к определенному элементу.
// Каждый элемент имеет указатель на следующий элемент
// Головной элемент указывает на NULL
//Достоинства: операция удаления и добавление элемента делаются за const время


#include <fstream> 
#include <locale.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <windows.h>
#include <iomanip>
#include <iostream>
#include <Windows.h>
#include <conio.h>
#include <locale.h>
#include <Bitset>
#include <vector>
#include <array>
#include <string>
using namespace std;

#include <stack>  // подключаем библиотеку для стека
using namespace std;

int main()
{
	setlocale(LC_ALL, "rus");
	/*	vector<int> vec1;
		int i;
		vec1.clear(); //очистить массив
		vec1.insert; //
		vec1.push_back; //
		vec1[i] = 10;
		vec1.size(); // выявление длины
		vec1.max_size();
	*/
	stack <char> stack;
	string mes;
	int i, kv, kz, kr;  // kv,kz,kr нужны для удобства проверки
	cout << "Введите сообщение: ";
	getline(cin, mes);
	for (i = 0; i < mes.length(); i++) // идем от по всему сообщению
	{
		if ((mes[i] == *"(") || (mes[i] == *"[") || (mes[i] == *"{")) stack.push(mes[i]); // Если скобка открытая, мы ее пушим

		// Если нахоим закртыю скобку и перед ней того же типа, но открытая и размер стака не равен 0 (чтоб не крашилось при сравнении с топом), то мы удаляем противоположную скобку в стаке
		if (stack.size() != 0 && (((mes[i] == *")") && (stack.top() == *"(")) || ((mes[i] == *"]") && (stack.top() == *"[")) || ((mes[i] == *"}") && (stack.top() == *"{")))) stack.pop();

		// Если мы не находим противоположную скобку, мы пушим в стак, для того чтобы исключить вариант при которой сначало открывается скобка или остаются лишнии 
		else if ((mes[i] == *")") || (mes[i] == *"]") || (mes[i] == *"}")) stack.push(mes[i]);
		/*if (mes[i] == *"(") // Если нашли " ( " , пушим в стак
		{
			kv++;
			stack.push(mes[i]);
			cout << "Вывод стака: " << kv << stack.top() << endl;
		}
		if (mes[i] == *")" && stack.size() > 0 && stack.top() == *"(") // Если нашли " ) " и перед ней есть " ( ", попаем
		{
			kv--;
			cout << "Вывод стака: " << kv << endl;
			stack.pop();
		}
		else if (mes[i] == *")") // Если же у нас нет перед ней нет " ( " , то пушим для того чтобы выдать False т.к она лишняя
		{
			stack.push(mes[i]);
			cout << "Вывод стака: " << stack.top() << endl;
		}

		if (mes[i] == *"[")
		{
			kz++;
			stack.push(mes[i]);
			cout << "Вывод стака: " << kz << stack.top() << endl;
		}
		if (mes[i] == *"]" && stack.size() > 0 && stack.top() == *"[")
		{
			kz--;
			cout << "Вывод стака: " << kz << endl;
			stack.pop();
		}
		else if (mes[i] == *"]")
		{
			stack.push(mes[i]);
			cout << "Вывод стака: " << stack.top() << endl;
		}

		if (mes[i] == *"{")
		{
			kr++;
			stack.push(mes[i]);
			cout << "Вывод стака: " << kr << stack.top() << endl;
		}
		if (mes[i] == *"}" && stack.size() > 0 && stack.top() == *"{")
		{
			kr--;
			cout << "Вывод стака: " << kr << endl;
			stack.pop();
		}
		else if (mes[i] == *"}")
		{
			stack.push(mes[i]);
			cout << "Вывод стака: " << stack.top() << endl;
		}*/
	}

	// Проверка стака на пустоту
	if (stack.empty()) cout << "Стак пуст \n" << "True " << endl;
	else cout << "Стак не пуст: " << stack.size() << "\nFalse " << endl;
	system("pause");
	return 0;
}