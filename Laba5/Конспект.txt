//4. ПЕРЕДАЧА ПАРАМЕТРОВ ПО ССЫЛКЕ И ПО ЗНАЧЕНИЮ
// Параметр переданный в fun обычным образом передается в виде локальной копии
// и любые его изменения в fun остаются исключительно внутри fun
// чтобы fun производила операции над оригиналом параметра
// его следует объявить со значком "&" т.н. передача по ссылке
// используется как один из способов вывода параметров из fun
// фактически при этом в fun передается указатель double*b и double*c 
// и внутри функции производится (*b) = 0.0 (*c) = 100500.0
/*
int fnc2ptr(double const a, double * b, double * c)
{
	int i = a * (*b) * (*c);
	(*c) = 100500;
	(*b) = 0;
	return a + (*c);
}
*/
#include "stdafx.h"
#include <iostream>
#include <Windows.h>
#include <conio.h>
#include <locale.h>
#include <Bitset>
using namespace std;

int main()
{
	//Lab5.cpp
	/* 1. СИНТАКСИС ОЬЪЯВЛЕНИЯ КЛАССА
	class Имя_Класса
	{
	 int hp;  число ХП
	 double speed;	скорость персонажа
	 void heal();	восстановление ХП
	 void move();	проигрывание анимации движения
	}

	Определение класса и обЪекта
	свойство (property) - переменная в составе класса
	метод (method) - функция в составе класса */

	class vehicle // игровое транспортное средство
	{
	public:
		vehile() /*Могут быть входные параметры!*/ // конструктор
		{
			std::cout << "constructor (vehicle)" <<std::endl;
			return;
		}

		~vehile() /*Не могут быть входные параметры!*/ // деструктор
		{
			std::cout << "~constructor of vehicle" << std::endl;
			return;
		}

		double speed; // скорость
		char regnumber[6]; // госномер
		unsigned char capacity; // число пасажиров

		bool chech regnumber(); // проверить номера, если зареган - true
		{
			//если метод небольшой - определение прямо в классе

			// если номер K370AO возвращает true
			const char * true_number = "K370AO";
			bool result = true

				for (int i = 0; i < 6; i++) 
					result = result && (true_number[i] == regnumber[i]);
				
			// запустить цикл проверки по всем 6-и символам строки regnumber
			// если все элементы совпадают с true_number - return true;
			return true;
		}
		void add_passenger(int passengers);
		void accelerate(double delta_velocity);


	}
	getchar();
	return 0;
}

/*
2. СИНТАКСИС ОБЪЯВЛЕНИЯ ОБЪЕКТА И ОБРАЩЕНИЯ К СВОЙСТВАМ И МЕТОДАМ
Имя_Класса объект1;
объект1.свойство1 = 1;
объект1.метод3(); */

//3. СПЕЦИФИКАТТОРЫ ДОСТУПА
// К полям (свойствам и методам), объявленным в разделе public:
//можно обращаться везде (и из методов класса, и снаружи, где виден объект)
// К полям private и protected можно обращаться только из методов 
// самого класса. Различие между private и protected объясняется в следующей теме
// про наследование классов

//4. КОНСТРУКТОР И ДЕСТРУКТОР КЛАССА
// Несмотря на то что программист не прописывает вызов в ручную... 
	Компилятор при анализе текста отслеживает когда объект появляется и исчезает
		автоматически подсталяет конструктора и деструктора в коде
// В случае, если при создании объекта нужно выполнять сложные действия по
// инициализации, установлению сетевого соединения, действия с файлами,
// выделение ОП и т.д эти действия прописываются в специальном методе -конструкторе
// Конструктор вызывается автоматически при создании объекта
// В случае если при исчезновении объекта нужно общие системные ресурсы освобождения
// закрывать порты, освобождать ОП, сохранять файлы и т.д - эти действия
// прописываются в методе - деструктуре (вызывается автоматически при исчезновении)
// конструктор не может возвращать параметры, но может иметь входные параметры
// деструктор не может иметь ни входных, ни выходных
// конструктором и деструктором автоматически назначается функция
// имеющая то же имя, что и класс (деструктор с "~"
// конструктор должен быть public

//5. СТРУКТУРЫ
// несмотря на то, что в литературе структура как правило хранит только данные
// на самом деле это то же самое, что и класс. Кд отличие - поля по умолчанию public

struct some_structure
{

}

//6. ОПРЕДЕЛЕНИЕ МЕТОДОВ СНАРУЖИ КЛАССА
// * в объявлении класса остается объявление (заголовок) метода
// * тело метода переносится наружу вместе с копией заголовка
// * к заголовку реализации добавляется "имя_класса::"

// 7. КЛЮЧЕВОЕ СЛОВО THIS
// this может использоваться только внутри методов класса
// это указатель на объект, вызвавший метод

// 8. УКАЗАТЕЛИ НА ОБЪЕКТ
// При работе с указателем на объект вместо точки
// для обращения к полям используется ->
// Объекты можно размещать в динамической памяти аналогично другим данным
// В этом случае сначала 1) объявляется указатель на объект
// затем 2) с помощью new объект создается и заполняется в ДП, при этом автоматически вызывается конструктор класса
// только после этого к полям объекта можно обращаться через "->"
